// Code generated by mockery v2.38.0. DO NOT EDIT.

package db

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockQuerier is an autogenerated mock type for the Querier type
type MockQuerier struct {
	mock.Mock
}

type MockQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQuerier) EXPECT() *MockQuerier_Expecter {
	return &MockQuerier_Expecter{mock: &_m.Mock}
}

// CreateCertificate provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateCertificate(ctx context.Context, db DBTX, arg CreateCertificateParams) (Certificate, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateCertificate")
	}

	var r0 Certificate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateCertificateParams) (Certificate, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateCertificateParams) Certificate); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(Certificate)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, CreateCertificateParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCertificate'
type MockQuerier_CreateCertificate_Call struct {
	*mock.Call
}

// CreateCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreateCertificateParams
func (_e *MockQuerier_Expecter) CreateCertificate(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateCertificate_Call {
	return &MockQuerier_CreateCertificate_Call{Call: _e.mock.On("CreateCertificate", ctx, db, arg)}
}

func (_c *MockQuerier_CreateCertificate_Call) Run(run func(ctx context.Context, db DBTX, arg CreateCertificateParams)) *MockQuerier_CreateCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreateCertificateParams))
	})
	return _c
}

func (_c *MockQuerier_CreateCertificate_Call) Return(_a0 Certificate, _a1 error) *MockQuerier_CreateCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateCertificate_Call) RunAndReturn(run func(context.Context, DBTX, CreateCertificateParams) (Certificate, error)) *MockQuerier_CreateCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCourse provides a mock function with given fields: ctx, db, data
func (_m *MockQuerier) CreateCourse(ctx context.Context, db DBTX, data []byte) (Course, error) {
	ret := _m.Called(ctx, db, data)

	if len(ret) == 0 {
		panic("no return value specified for CreateCourse")
	}

	var r0 Course
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []byte) (Course, error)); ok {
		return rf(ctx, db, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []byte) Course); ok {
		r0 = rf(ctx, db, data)
	} else {
		r0 = ret.Get(0).(Course)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, []byte) error); ok {
		r1 = rf(ctx, db, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateCourse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCourse'
type MockQuerier_CreateCourse_Call struct {
	*mock.Call
}

// CreateCourse is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - data []byte
func (_e *MockQuerier_Expecter) CreateCourse(ctx interface{}, db interface{}, data interface{}) *MockQuerier_CreateCourse_Call {
	return &MockQuerier_CreateCourse_Call{Call: _e.mock.On("CreateCourse", ctx, db, data)}
}

func (_c *MockQuerier_CreateCourse_Call) Run(run func(ctx context.Context, db DBTX, data []byte)) *MockQuerier_CreateCourse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].([]byte))
	})
	return _c
}

func (_c *MockQuerier_CreateCourse_Call) Return(_a0 Course, _a1 error) *MockQuerier_CreateCourse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateCourse_Call) RunAndReturn(run func(context.Context, DBTX, []byte) (Course, error)) *MockQuerier_CreateCourse_Call {
	_c.Call.Return(run)
	return _c
}

// CreateStudent provides a mock function with given fields: ctx, db, data
func (_m *MockQuerier) CreateStudent(ctx context.Context, db DBTX, data []byte) (Student, error) {
	ret := _m.Called(ctx, db, data)

	if len(ret) == 0 {
		panic("no return value specified for CreateStudent")
	}

	var r0 Student
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []byte) (Student, error)); ok {
		return rf(ctx, db, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []byte) Student); ok {
		r0 = rf(ctx, db, data)
	} else {
		r0 = ret.Get(0).(Student)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, []byte) error); ok {
		r1 = rf(ctx, db, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateStudent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStudent'
type MockQuerier_CreateStudent_Call struct {
	*mock.Call
}

// CreateStudent is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - data []byte
func (_e *MockQuerier_Expecter) CreateStudent(ctx interface{}, db interface{}, data interface{}) *MockQuerier_CreateStudent_Call {
	return &MockQuerier_CreateStudent_Call{Call: _e.mock.On("CreateStudent", ctx, db, data)}
}

func (_c *MockQuerier_CreateStudent_Call) Run(run func(ctx context.Context, db DBTX, data []byte)) *MockQuerier_CreateStudent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].([]byte))
	})
	return _c
}

func (_c *MockQuerier_CreateStudent_Call) Return(_a0 Student, _a1 error) *MockQuerier_CreateStudent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateStudent_Call) RunAndReturn(run func(context.Context, DBTX, []byte) (Student, error)) *MockQuerier_CreateStudent_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTemplate provides a mock function with given fields: ctx, db, content
func (_m *MockQuerier) CreateTemplate(ctx context.Context, db DBTX, content string) (Template, error) {
	ret := _m.Called(ctx, db, content)

	if len(ret) == 0 {
		panic("no return value specified for CreateTemplate")
	}

	var r0 Template
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) (Template, error)); ok {
		return rf(ctx, db, content)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) Template); ok {
		r0 = rf(ctx, db, content)
	} else {
		r0 = ret.Get(0).(Template)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, string) error); ok {
		r1 = rf(ctx, db, content)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTemplate'
type MockQuerier_CreateTemplate_Call struct {
	*mock.Call
}

// CreateTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - content string
func (_e *MockQuerier_Expecter) CreateTemplate(ctx interface{}, db interface{}, content interface{}) *MockQuerier_CreateTemplate_Call {
	return &MockQuerier_CreateTemplate_Call{Call: _e.mock.On("CreateTemplate", ctx, db, content)}
}

func (_c *MockQuerier_CreateTemplate_Call) Run(run func(ctx context.Context, db DBTX, content string)) *MockQuerier_CreateTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_CreateTemplate_Call) Return(_a0 Template, _a1 error) *MockQuerier_CreateTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateTemplate_Call) RunAndReturn(run func(context.Context, DBTX, string) (Template, error)) *MockQuerier_CreateTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCertificate provides a mock function with given fields: ctx, db, certificateID
func (_m *MockQuerier) DeleteCertificate(ctx context.Context, db DBTX, certificateID string) (Certificate, error) {
	ret := _m.Called(ctx, db, certificateID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCertificate")
	}

	var r0 Certificate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) (Certificate, error)); ok {
		return rf(ctx, db, certificateID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) Certificate); ok {
		r0 = rf(ctx, db, certificateID)
	} else {
		r0 = ret.Get(0).(Certificate)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, string) error); ok {
		r1 = rf(ctx, db, certificateID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_DeleteCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCertificate'
type MockQuerier_DeleteCertificate_Call struct {
	*mock.Call
}

// DeleteCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - certificateID string
func (_e *MockQuerier_Expecter) DeleteCertificate(ctx interface{}, db interface{}, certificateID interface{}) *MockQuerier_DeleteCertificate_Call {
	return &MockQuerier_DeleteCertificate_Call{Call: _e.mock.On("DeleteCertificate", ctx, db, certificateID)}
}

func (_c *MockQuerier_DeleteCertificate_Call) Run(run func(ctx context.Context, db DBTX, certificateID string)) *MockQuerier_DeleteCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_DeleteCertificate_Call) Return(_a0 Certificate, _a1 error) *MockQuerier_DeleteCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_DeleteCertificate_Call) RunAndReturn(run func(context.Context, DBTX, string) (Certificate, error)) *MockQuerier_DeleteCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCourse provides a mock function with given fields: ctx, db, courseID
func (_m *MockQuerier) DeleteCourse(ctx context.Context, db DBTX, courseID int32) (Course, error) {
	ret := _m.Called(ctx, db, courseID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCourse")
	}

	var r0 Course
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) (Course, error)); ok {
		return rf(ctx, db, courseID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) Course); ok {
		r0 = rf(ctx, db, courseID)
	} else {
		r0 = ret.Get(0).(Course)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, int32) error); ok {
		r1 = rf(ctx, db, courseID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_DeleteCourse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCourse'
type MockQuerier_DeleteCourse_Call struct {
	*mock.Call
}

// DeleteCourse is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - courseID int32
func (_e *MockQuerier_Expecter) DeleteCourse(ctx interface{}, db interface{}, courseID interface{}) *MockQuerier_DeleteCourse_Call {
	return &MockQuerier_DeleteCourse_Call{Call: _e.mock.On("DeleteCourse", ctx, db, courseID)}
}

func (_c *MockQuerier_DeleteCourse_Call) Run(run func(ctx context.Context, db DBTX, courseID int32)) *MockQuerier_DeleteCourse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(int32))
	})
	return _c
}

func (_c *MockQuerier_DeleteCourse_Call) Return(_a0 Course, _a1 error) *MockQuerier_DeleteCourse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_DeleteCourse_Call) RunAndReturn(run func(context.Context, DBTX, int32) (Course, error)) *MockQuerier_DeleteCourse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteStudent provides a mock function with given fields: ctx, db, studentID
func (_m *MockQuerier) DeleteStudent(ctx context.Context, db DBTX, studentID int32) (Student, error) {
	ret := _m.Called(ctx, db, studentID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStudent")
	}

	var r0 Student
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) (Student, error)); ok {
		return rf(ctx, db, studentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) Student); ok {
		r0 = rf(ctx, db, studentID)
	} else {
		r0 = ret.Get(0).(Student)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, int32) error); ok {
		r1 = rf(ctx, db, studentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_DeleteStudent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteStudent'
type MockQuerier_DeleteStudent_Call struct {
	*mock.Call
}

// DeleteStudent is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - studentID int32
func (_e *MockQuerier_Expecter) DeleteStudent(ctx interface{}, db interface{}, studentID interface{}) *MockQuerier_DeleteStudent_Call {
	return &MockQuerier_DeleteStudent_Call{Call: _e.mock.On("DeleteStudent", ctx, db, studentID)}
}

func (_c *MockQuerier_DeleteStudent_Call) Run(run func(ctx context.Context, db DBTX, studentID int32)) *MockQuerier_DeleteStudent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(int32))
	})
	return _c
}

func (_c *MockQuerier_DeleteStudent_Call) Return(_a0 Student, _a1 error) *MockQuerier_DeleteStudent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_DeleteStudent_Call) RunAndReturn(run func(context.Context, DBTX, int32) (Student, error)) *MockQuerier_DeleteStudent_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTemplate provides a mock function with given fields: ctx, db, templateID
func (_m *MockQuerier) DeleteTemplate(ctx context.Context, db DBTX, templateID int32) (Template, error) {
	ret := _m.Called(ctx, db, templateID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTemplate")
	}

	var r0 Template
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) (Template, error)); ok {
		return rf(ctx, db, templateID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) Template); ok {
		r0 = rf(ctx, db, templateID)
	} else {
		r0 = ret.Get(0).(Template)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, int32) error); ok {
		r1 = rf(ctx, db, templateID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_DeleteTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTemplate'
type MockQuerier_DeleteTemplate_Call struct {
	*mock.Call
}

// DeleteTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - templateID int32
func (_e *MockQuerier_Expecter) DeleteTemplate(ctx interface{}, db interface{}, templateID interface{}) *MockQuerier_DeleteTemplate_Call {
	return &MockQuerier_DeleteTemplate_Call{Call: _e.mock.On("DeleteTemplate", ctx, db, templateID)}
}

func (_c *MockQuerier_DeleteTemplate_Call) Run(run func(ctx context.Context, db DBTX, templateID int32)) *MockQuerier_DeleteTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(int32))
	})
	return _c
}

func (_c *MockQuerier_DeleteTemplate_Call) Return(_a0 Template, _a1 error) *MockQuerier_DeleteTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_DeleteTemplate_Call) RunAndReturn(run func(context.Context, DBTX, int32) (Template, error)) *MockQuerier_DeleteTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// GetCertificate provides a mock function with given fields: ctx, db, certificateID
func (_m *MockQuerier) GetCertificate(ctx context.Context, db DBTX, certificateID string) (Certificate, error) {
	ret := _m.Called(ctx, db, certificateID)

	if len(ret) == 0 {
		panic("no return value specified for GetCertificate")
	}

	var r0 Certificate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) (Certificate, error)); ok {
		return rf(ctx, db, certificateID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) Certificate); ok {
		r0 = rf(ctx, db, certificateID)
	} else {
		r0 = ret.Get(0).(Certificate)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, string) error); ok {
		r1 = rf(ctx, db, certificateID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCertificate'
type MockQuerier_GetCertificate_Call struct {
	*mock.Call
}

// GetCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - certificateID string
func (_e *MockQuerier_Expecter) GetCertificate(ctx interface{}, db interface{}, certificateID interface{}) *MockQuerier_GetCertificate_Call {
	return &MockQuerier_GetCertificate_Call{Call: _e.mock.On("GetCertificate", ctx, db, certificateID)}
}

func (_c *MockQuerier_GetCertificate_Call) Run(run func(ctx context.Context, db DBTX, certificateID string)) *MockQuerier_GetCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_GetCertificate_Call) Return(_a0 Certificate, _a1 error) *MockQuerier_GetCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetCertificate_Call) RunAndReturn(run func(context.Context, DBTX, string) (Certificate, error)) *MockQuerier_GetCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// GetCourse provides a mock function with given fields: ctx, db, courseID
func (_m *MockQuerier) GetCourse(ctx context.Context, db DBTX, courseID int32) (Course, error) {
	ret := _m.Called(ctx, db, courseID)

	if len(ret) == 0 {
		panic("no return value specified for GetCourse")
	}

	var r0 Course
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) (Course, error)); ok {
		return rf(ctx, db, courseID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) Course); ok {
		r0 = rf(ctx, db, courseID)
	} else {
		r0 = ret.Get(0).(Course)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, int32) error); ok {
		r1 = rf(ctx, db, courseID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetCourse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCourse'
type MockQuerier_GetCourse_Call struct {
	*mock.Call
}

// GetCourse is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - courseID int32
func (_e *MockQuerier_Expecter) GetCourse(ctx interface{}, db interface{}, courseID interface{}) *MockQuerier_GetCourse_Call {
	return &MockQuerier_GetCourse_Call{Call: _e.mock.On("GetCourse", ctx, db, courseID)}
}

func (_c *MockQuerier_GetCourse_Call) Run(run func(ctx context.Context, db DBTX, courseID int32)) *MockQuerier_GetCourse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(int32))
	})
	return _c
}

func (_c *MockQuerier_GetCourse_Call) Return(_a0 Course, _a1 error) *MockQuerier_GetCourse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetCourse_Call) RunAndReturn(run func(context.Context, DBTX, int32) (Course, error)) *MockQuerier_GetCourse_Call {
	_c.Call.Return(run)
	return _c
}

// GetStudent provides a mock function with given fields: ctx, db, studentID
func (_m *MockQuerier) GetStudent(ctx context.Context, db DBTX, studentID int32) (Student, error) {
	ret := _m.Called(ctx, db, studentID)

	if len(ret) == 0 {
		panic("no return value specified for GetStudent")
	}

	var r0 Student
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) (Student, error)); ok {
		return rf(ctx, db, studentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) Student); ok {
		r0 = rf(ctx, db, studentID)
	} else {
		r0 = ret.Get(0).(Student)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, int32) error); ok {
		r1 = rf(ctx, db, studentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetStudent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStudent'
type MockQuerier_GetStudent_Call struct {
	*mock.Call
}

// GetStudent is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - studentID int32
func (_e *MockQuerier_Expecter) GetStudent(ctx interface{}, db interface{}, studentID interface{}) *MockQuerier_GetStudent_Call {
	return &MockQuerier_GetStudent_Call{Call: _e.mock.On("GetStudent", ctx, db, studentID)}
}

func (_c *MockQuerier_GetStudent_Call) Run(run func(ctx context.Context, db DBTX, studentID int32)) *MockQuerier_GetStudent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(int32))
	})
	return _c
}

func (_c *MockQuerier_GetStudent_Call) Return(_a0 Student, _a1 error) *MockQuerier_GetStudent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetStudent_Call) RunAndReturn(run func(context.Context, DBTX, int32) (Student, error)) *MockQuerier_GetStudent_Call {
	_c.Call.Return(run)
	return _c
}

// GetTemplate provides a mock function with given fields: ctx, db, templateID
func (_m *MockQuerier) GetTemplate(ctx context.Context, db DBTX, templateID int32) (Template, error) {
	ret := _m.Called(ctx, db, templateID)

	if len(ret) == 0 {
		panic("no return value specified for GetTemplate")
	}

	var r0 Template
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) (Template, error)); ok {
		return rf(ctx, db, templateID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) Template); ok {
		r0 = rf(ctx, db, templateID)
	} else {
		r0 = ret.Get(0).(Template)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, int32) error); ok {
		r1 = rf(ctx, db, templateID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTemplate'
type MockQuerier_GetTemplate_Call struct {
	*mock.Call
}

// GetTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - templateID int32
func (_e *MockQuerier_Expecter) GetTemplate(ctx interface{}, db interface{}, templateID interface{}) *MockQuerier_GetTemplate_Call {
	return &MockQuerier_GetTemplate_Call{Call: _e.mock.On("GetTemplate", ctx, db, templateID)}
}

func (_c *MockQuerier_GetTemplate_Call) Run(run func(ctx context.Context, db DBTX, templateID int32)) *MockQuerier_GetTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(int32))
	})
	return _c
}

func (_c *MockQuerier_GetTemplate_Call) Return(_a0 Template, _a1 error) *MockQuerier_GetTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetTemplate_Call) RunAndReturn(run func(context.Context, DBTX, int32) (Template, error)) *MockQuerier_GetTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// ListCertificates provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) ListCertificates(ctx context.Context, db DBTX, arg ListCertificatesParams) ([]Certificate, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for ListCertificates")
	}

	var r0 []Certificate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListCertificatesParams) ([]Certificate, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListCertificatesParams) []Certificate); ok {
		r0 = rf(ctx, db, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Certificate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, ListCertificatesParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListCertificates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCertificates'
type MockQuerier_ListCertificates_Call struct {
	*mock.Call
}

// ListCertificates is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg ListCertificatesParams
func (_e *MockQuerier_Expecter) ListCertificates(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_ListCertificates_Call {
	return &MockQuerier_ListCertificates_Call{Call: _e.mock.On("ListCertificates", ctx, db, arg)}
}

func (_c *MockQuerier_ListCertificates_Call) Run(run func(ctx context.Context, db DBTX, arg ListCertificatesParams)) *MockQuerier_ListCertificates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(ListCertificatesParams))
	})
	return _c
}

func (_c *MockQuerier_ListCertificates_Call) Return(_a0 []Certificate, _a1 error) *MockQuerier_ListCertificates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListCertificates_Call) RunAndReturn(run func(context.Context, DBTX, ListCertificatesParams) ([]Certificate, error)) *MockQuerier_ListCertificates_Call {
	_c.Call.Return(run)
	return _c
}

// ListCertificatesByCourse provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) ListCertificatesByCourse(ctx context.Context, db DBTX, arg ListCertificatesByCourseParams) ([]Certificate, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for ListCertificatesByCourse")
	}

	var r0 []Certificate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListCertificatesByCourseParams) ([]Certificate, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListCertificatesByCourseParams) []Certificate); ok {
		r0 = rf(ctx, db, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Certificate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, ListCertificatesByCourseParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListCertificatesByCourse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCertificatesByCourse'
type MockQuerier_ListCertificatesByCourse_Call struct {
	*mock.Call
}

// ListCertificatesByCourse is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg ListCertificatesByCourseParams
func (_e *MockQuerier_Expecter) ListCertificatesByCourse(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_ListCertificatesByCourse_Call {
	return &MockQuerier_ListCertificatesByCourse_Call{Call: _e.mock.On("ListCertificatesByCourse", ctx, db, arg)}
}

func (_c *MockQuerier_ListCertificatesByCourse_Call) Run(run func(ctx context.Context, db DBTX, arg ListCertificatesByCourseParams)) *MockQuerier_ListCertificatesByCourse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(ListCertificatesByCourseParams))
	})
	return _c
}

func (_c *MockQuerier_ListCertificatesByCourse_Call) Return(_a0 []Certificate, _a1 error) *MockQuerier_ListCertificatesByCourse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListCertificatesByCourse_Call) RunAndReturn(run func(context.Context, DBTX, ListCertificatesByCourseParams) ([]Certificate, error)) *MockQuerier_ListCertificatesByCourse_Call {
	_c.Call.Return(run)
	return _c
}

// ListCertificatesByCourseLen provides a mock function with given fields: ctx, db, courseID
func (_m *MockQuerier) ListCertificatesByCourseLen(ctx context.Context, db DBTX, courseID int32) (int64, error) {
	ret := _m.Called(ctx, db, courseID)

	if len(ret) == 0 {
		panic("no return value specified for ListCertificatesByCourseLen")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) (int64, error)); ok {
		return rf(ctx, db, courseID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) int64); ok {
		r0 = rf(ctx, db, courseID)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, int32) error); ok {
		r1 = rf(ctx, db, courseID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListCertificatesByCourseLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCertificatesByCourseLen'
type MockQuerier_ListCertificatesByCourseLen_Call struct {
	*mock.Call
}

// ListCertificatesByCourseLen is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - courseID int32
func (_e *MockQuerier_Expecter) ListCertificatesByCourseLen(ctx interface{}, db interface{}, courseID interface{}) *MockQuerier_ListCertificatesByCourseLen_Call {
	return &MockQuerier_ListCertificatesByCourseLen_Call{Call: _e.mock.On("ListCertificatesByCourseLen", ctx, db, courseID)}
}

func (_c *MockQuerier_ListCertificatesByCourseLen_Call) Run(run func(ctx context.Context, db DBTX, courseID int32)) *MockQuerier_ListCertificatesByCourseLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(int32))
	})
	return _c
}

func (_c *MockQuerier_ListCertificatesByCourseLen_Call) Return(_a0 int64, _a1 error) *MockQuerier_ListCertificatesByCourseLen_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListCertificatesByCourseLen_Call) RunAndReturn(run func(context.Context, DBTX, int32) (int64, error)) *MockQuerier_ListCertificatesByCourseLen_Call {
	_c.Call.Return(run)
	return _c
}

// ListCertificatesByStudent provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) ListCertificatesByStudent(ctx context.Context, db DBTX, arg ListCertificatesByStudentParams) ([]Certificate, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for ListCertificatesByStudent")
	}

	var r0 []Certificate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListCertificatesByStudentParams) ([]Certificate, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListCertificatesByStudentParams) []Certificate); ok {
		r0 = rf(ctx, db, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Certificate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, ListCertificatesByStudentParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListCertificatesByStudent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCertificatesByStudent'
type MockQuerier_ListCertificatesByStudent_Call struct {
	*mock.Call
}

// ListCertificatesByStudent is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg ListCertificatesByStudentParams
func (_e *MockQuerier_Expecter) ListCertificatesByStudent(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_ListCertificatesByStudent_Call {
	return &MockQuerier_ListCertificatesByStudent_Call{Call: _e.mock.On("ListCertificatesByStudent", ctx, db, arg)}
}

func (_c *MockQuerier_ListCertificatesByStudent_Call) Run(run func(ctx context.Context, db DBTX, arg ListCertificatesByStudentParams)) *MockQuerier_ListCertificatesByStudent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(ListCertificatesByStudentParams))
	})
	return _c
}

func (_c *MockQuerier_ListCertificatesByStudent_Call) Return(_a0 []Certificate, _a1 error) *MockQuerier_ListCertificatesByStudent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListCertificatesByStudent_Call) RunAndReturn(run func(context.Context, DBTX, ListCertificatesByStudentParams) ([]Certificate, error)) *MockQuerier_ListCertificatesByStudent_Call {
	_c.Call.Return(run)
	return _c
}

// ListCertificatesByStudentLen provides a mock function with given fields: ctx, db, studentID
func (_m *MockQuerier) ListCertificatesByStudentLen(ctx context.Context, db DBTX, studentID int32) (int64, error) {
	ret := _m.Called(ctx, db, studentID)

	if len(ret) == 0 {
		panic("no return value specified for ListCertificatesByStudentLen")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) (int64, error)); ok {
		return rf(ctx, db, studentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) int64); ok {
		r0 = rf(ctx, db, studentID)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, int32) error); ok {
		r1 = rf(ctx, db, studentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListCertificatesByStudentLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCertificatesByStudentLen'
type MockQuerier_ListCertificatesByStudentLen_Call struct {
	*mock.Call
}

// ListCertificatesByStudentLen is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - studentID int32
func (_e *MockQuerier_Expecter) ListCertificatesByStudentLen(ctx interface{}, db interface{}, studentID interface{}) *MockQuerier_ListCertificatesByStudentLen_Call {
	return &MockQuerier_ListCertificatesByStudentLen_Call{Call: _e.mock.On("ListCertificatesByStudentLen", ctx, db, studentID)}
}

func (_c *MockQuerier_ListCertificatesByStudentLen_Call) Run(run func(ctx context.Context, db DBTX, studentID int32)) *MockQuerier_ListCertificatesByStudentLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(int32))
	})
	return _c
}

func (_c *MockQuerier_ListCertificatesByStudentLen_Call) Return(_a0 int64, _a1 error) *MockQuerier_ListCertificatesByStudentLen_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListCertificatesByStudentLen_Call) RunAndReturn(run func(context.Context, DBTX, int32) (int64, error)) *MockQuerier_ListCertificatesByStudentLen_Call {
	_c.Call.Return(run)
	return _c
}

// ListCertificatesByTemplate provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) ListCertificatesByTemplate(ctx context.Context, db DBTX, arg ListCertificatesByTemplateParams) ([]Certificate, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for ListCertificatesByTemplate")
	}

	var r0 []Certificate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListCertificatesByTemplateParams) ([]Certificate, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListCertificatesByTemplateParams) []Certificate); ok {
		r0 = rf(ctx, db, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Certificate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, ListCertificatesByTemplateParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListCertificatesByTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCertificatesByTemplate'
type MockQuerier_ListCertificatesByTemplate_Call struct {
	*mock.Call
}

// ListCertificatesByTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg ListCertificatesByTemplateParams
func (_e *MockQuerier_Expecter) ListCertificatesByTemplate(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_ListCertificatesByTemplate_Call {
	return &MockQuerier_ListCertificatesByTemplate_Call{Call: _e.mock.On("ListCertificatesByTemplate", ctx, db, arg)}
}

func (_c *MockQuerier_ListCertificatesByTemplate_Call) Run(run func(ctx context.Context, db DBTX, arg ListCertificatesByTemplateParams)) *MockQuerier_ListCertificatesByTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(ListCertificatesByTemplateParams))
	})
	return _c
}

func (_c *MockQuerier_ListCertificatesByTemplate_Call) Return(_a0 []Certificate, _a1 error) *MockQuerier_ListCertificatesByTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListCertificatesByTemplate_Call) RunAndReturn(run func(context.Context, DBTX, ListCertificatesByTemplateParams) ([]Certificate, error)) *MockQuerier_ListCertificatesByTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// ListCertificatesByTemplateLen provides a mock function with given fields: ctx, db, templateID
func (_m *MockQuerier) ListCertificatesByTemplateLen(ctx context.Context, db DBTX, templateID int32) (int64, error) {
	ret := _m.Called(ctx, db, templateID)

	if len(ret) == 0 {
		panic("no return value specified for ListCertificatesByTemplateLen")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) (int64, error)); ok {
		return rf(ctx, db, templateID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, int32) int64); ok {
		r0 = rf(ctx, db, templateID)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, int32) error); ok {
		r1 = rf(ctx, db, templateID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListCertificatesByTemplateLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCertificatesByTemplateLen'
type MockQuerier_ListCertificatesByTemplateLen_Call struct {
	*mock.Call
}

// ListCertificatesByTemplateLen is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - templateID int32
func (_e *MockQuerier_Expecter) ListCertificatesByTemplateLen(ctx interface{}, db interface{}, templateID interface{}) *MockQuerier_ListCertificatesByTemplateLen_Call {
	return &MockQuerier_ListCertificatesByTemplateLen_Call{Call: _e.mock.On("ListCertificatesByTemplateLen", ctx, db, templateID)}
}

func (_c *MockQuerier_ListCertificatesByTemplateLen_Call) Run(run func(ctx context.Context, db DBTX, templateID int32)) *MockQuerier_ListCertificatesByTemplateLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(int32))
	})
	return _c
}

func (_c *MockQuerier_ListCertificatesByTemplateLen_Call) Return(_a0 int64, _a1 error) *MockQuerier_ListCertificatesByTemplateLen_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListCertificatesByTemplateLen_Call) RunAndReturn(run func(context.Context, DBTX, int32) (int64, error)) *MockQuerier_ListCertificatesByTemplateLen_Call {
	_c.Call.Return(run)
	return _c
}

// ListCertificatesLen provides a mock function with given fields: ctx, db
func (_m *MockQuerier) ListCertificatesLen(ctx context.Context, db DBTX) (int64, error) {
	ret := _m.Called(ctx, db)

	if len(ret) == 0 {
		panic("no return value specified for ListCertificatesLen")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) (int64, error)); ok {
		return rf(ctx, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) int64); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX) error); ok {
		r1 = rf(ctx, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListCertificatesLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCertificatesLen'
type MockQuerier_ListCertificatesLen_Call struct {
	*mock.Call
}

// ListCertificatesLen is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
func (_e *MockQuerier_Expecter) ListCertificatesLen(ctx interface{}, db interface{}) *MockQuerier_ListCertificatesLen_Call {
	return &MockQuerier_ListCertificatesLen_Call{Call: _e.mock.On("ListCertificatesLen", ctx, db)}
}

func (_c *MockQuerier_ListCertificatesLen_Call) Run(run func(ctx context.Context, db DBTX)) *MockQuerier_ListCertificatesLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX))
	})
	return _c
}

func (_c *MockQuerier_ListCertificatesLen_Call) Return(_a0 int64, _a1 error) *MockQuerier_ListCertificatesLen_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListCertificatesLen_Call) RunAndReturn(run func(context.Context, DBTX) (int64, error)) *MockQuerier_ListCertificatesLen_Call {
	_c.Call.Return(run)
	return _c
}

// ListCourses provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) ListCourses(ctx context.Context, db DBTX, arg ListCoursesParams) ([]Course, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for ListCourses")
	}

	var r0 []Course
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListCoursesParams) ([]Course, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListCoursesParams) []Course); ok {
		r0 = rf(ctx, db, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Course)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, ListCoursesParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListCourses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCourses'
type MockQuerier_ListCourses_Call struct {
	*mock.Call
}

// ListCourses is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg ListCoursesParams
func (_e *MockQuerier_Expecter) ListCourses(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_ListCourses_Call {
	return &MockQuerier_ListCourses_Call{Call: _e.mock.On("ListCourses", ctx, db, arg)}
}

func (_c *MockQuerier_ListCourses_Call) Run(run func(ctx context.Context, db DBTX, arg ListCoursesParams)) *MockQuerier_ListCourses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(ListCoursesParams))
	})
	return _c
}

func (_c *MockQuerier_ListCourses_Call) Return(_a0 []Course, _a1 error) *MockQuerier_ListCourses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListCourses_Call) RunAndReturn(run func(context.Context, DBTX, ListCoursesParams) ([]Course, error)) *MockQuerier_ListCourses_Call {
	_c.Call.Return(run)
	return _c
}

// ListCoursesLen provides a mock function with given fields: ctx, db
func (_m *MockQuerier) ListCoursesLen(ctx context.Context, db DBTX) (int64, error) {
	ret := _m.Called(ctx, db)

	if len(ret) == 0 {
		panic("no return value specified for ListCoursesLen")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) (int64, error)); ok {
		return rf(ctx, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) int64); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX) error); ok {
		r1 = rf(ctx, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListCoursesLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCoursesLen'
type MockQuerier_ListCoursesLen_Call struct {
	*mock.Call
}

// ListCoursesLen is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
func (_e *MockQuerier_Expecter) ListCoursesLen(ctx interface{}, db interface{}) *MockQuerier_ListCoursesLen_Call {
	return &MockQuerier_ListCoursesLen_Call{Call: _e.mock.On("ListCoursesLen", ctx, db)}
}

func (_c *MockQuerier_ListCoursesLen_Call) Run(run func(ctx context.Context, db DBTX)) *MockQuerier_ListCoursesLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX))
	})
	return _c
}

func (_c *MockQuerier_ListCoursesLen_Call) Return(_a0 int64, _a1 error) *MockQuerier_ListCoursesLen_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListCoursesLen_Call) RunAndReturn(run func(context.Context, DBTX) (int64, error)) *MockQuerier_ListCoursesLen_Call {
	_c.Call.Return(run)
	return _c
}

// ListStudents provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) ListStudents(ctx context.Context, db DBTX, arg ListStudentsParams) ([]Student, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for ListStudents")
	}

	var r0 []Student
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListStudentsParams) ([]Student, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListStudentsParams) []Student); ok {
		r0 = rf(ctx, db, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Student)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, ListStudentsParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListStudents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListStudents'
type MockQuerier_ListStudents_Call struct {
	*mock.Call
}

// ListStudents is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg ListStudentsParams
func (_e *MockQuerier_Expecter) ListStudents(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_ListStudents_Call {
	return &MockQuerier_ListStudents_Call{Call: _e.mock.On("ListStudents", ctx, db, arg)}
}

func (_c *MockQuerier_ListStudents_Call) Run(run func(ctx context.Context, db DBTX, arg ListStudentsParams)) *MockQuerier_ListStudents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(ListStudentsParams))
	})
	return _c
}

func (_c *MockQuerier_ListStudents_Call) Return(_a0 []Student, _a1 error) *MockQuerier_ListStudents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListStudents_Call) RunAndReturn(run func(context.Context, DBTX, ListStudentsParams) ([]Student, error)) *MockQuerier_ListStudents_Call {
	_c.Call.Return(run)
	return _c
}

// ListStudentsLen provides a mock function with given fields: ctx, db
func (_m *MockQuerier) ListStudentsLen(ctx context.Context, db DBTX) (int64, error) {
	ret := _m.Called(ctx, db)

	if len(ret) == 0 {
		panic("no return value specified for ListStudentsLen")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) (int64, error)); ok {
		return rf(ctx, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) int64); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX) error); ok {
		r1 = rf(ctx, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListStudentsLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListStudentsLen'
type MockQuerier_ListStudentsLen_Call struct {
	*mock.Call
}

// ListStudentsLen is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
func (_e *MockQuerier_Expecter) ListStudentsLen(ctx interface{}, db interface{}) *MockQuerier_ListStudentsLen_Call {
	return &MockQuerier_ListStudentsLen_Call{Call: _e.mock.On("ListStudentsLen", ctx, db)}
}

func (_c *MockQuerier_ListStudentsLen_Call) Run(run func(ctx context.Context, db DBTX)) *MockQuerier_ListStudentsLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX))
	})
	return _c
}

func (_c *MockQuerier_ListStudentsLen_Call) Return(_a0 int64, _a1 error) *MockQuerier_ListStudentsLen_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListStudentsLen_Call) RunAndReturn(run func(context.Context, DBTX) (int64, error)) *MockQuerier_ListStudentsLen_Call {
	_c.Call.Return(run)
	return _c
}

// ListTemplates provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) ListTemplates(ctx context.Context, db DBTX, arg ListTemplatesParams) ([]Template, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for ListTemplates")
	}

	var r0 []Template
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListTemplatesParams) ([]Template, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ListTemplatesParams) []Template); ok {
		r0 = rf(ctx, db, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Template)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, ListTemplatesParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListTemplates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTemplates'
type MockQuerier_ListTemplates_Call struct {
	*mock.Call
}

// ListTemplates is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg ListTemplatesParams
func (_e *MockQuerier_Expecter) ListTemplates(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_ListTemplates_Call {
	return &MockQuerier_ListTemplates_Call{Call: _e.mock.On("ListTemplates", ctx, db, arg)}
}

func (_c *MockQuerier_ListTemplates_Call) Run(run func(ctx context.Context, db DBTX, arg ListTemplatesParams)) *MockQuerier_ListTemplates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(ListTemplatesParams))
	})
	return _c
}

func (_c *MockQuerier_ListTemplates_Call) Return(_a0 []Template, _a1 error) *MockQuerier_ListTemplates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListTemplates_Call) RunAndReturn(run func(context.Context, DBTX, ListTemplatesParams) ([]Template, error)) *MockQuerier_ListTemplates_Call {
	_c.Call.Return(run)
	return _c
}

// ListTemplatesLen provides a mock function with given fields: ctx, db
func (_m *MockQuerier) ListTemplatesLen(ctx context.Context, db DBTX) (int64, error) {
	ret := _m.Called(ctx, db)

	if len(ret) == 0 {
		panic("no return value specified for ListTemplatesLen")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) (int64, error)); ok {
		return rf(ctx, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) int64); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX) error); ok {
		r1 = rf(ctx, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ListTemplatesLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTemplatesLen'
type MockQuerier_ListTemplatesLen_Call struct {
	*mock.Call
}

// ListTemplatesLen is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
func (_e *MockQuerier_Expecter) ListTemplatesLen(ctx interface{}, db interface{}) *MockQuerier_ListTemplatesLen_Call {
	return &MockQuerier_ListTemplatesLen_Call{Call: _e.mock.On("ListTemplatesLen", ctx, db)}
}

func (_c *MockQuerier_ListTemplatesLen_Call) Run(run func(ctx context.Context, db DBTX)) *MockQuerier_ListTemplatesLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX))
	})
	return _c
}

func (_c *MockQuerier_ListTemplatesLen_Call) Return(_a0 int64, _a1 error) *MockQuerier_ListTemplatesLen_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ListTemplatesLen_Call) RunAndReturn(run func(context.Context, DBTX) (int64, error)) *MockQuerier_ListTemplatesLen_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCertificate provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateCertificate(ctx context.Context, db DBTX, arg UpdateCertificateParams) (Certificate, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCertificate")
	}

	var r0 Certificate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateCertificateParams) (Certificate, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateCertificateParams) Certificate); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(Certificate)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateCertificateParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCertificate'
type MockQuerier_UpdateCertificate_Call struct {
	*mock.Call
}

// UpdateCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateCertificateParams
func (_e *MockQuerier_Expecter) UpdateCertificate(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateCertificate_Call {
	return &MockQuerier_UpdateCertificate_Call{Call: _e.mock.On("UpdateCertificate", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateCertificate_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateCertificateParams)) *MockQuerier_UpdateCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateCertificateParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateCertificate_Call) Return(_a0 Certificate, _a1 error) *MockQuerier_UpdateCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateCertificate_Call) RunAndReturn(run func(context.Context, DBTX, UpdateCertificateParams) (Certificate, error)) *MockQuerier_UpdateCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCourse provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateCourse(ctx context.Context, db DBTX, arg UpdateCourseParams) (Course, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCourse")
	}

	var r0 Course
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateCourseParams) (Course, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateCourseParams) Course); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(Course)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateCourseParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateCourse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCourse'
type MockQuerier_UpdateCourse_Call struct {
	*mock.Call
}

// UpdateCourse is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateCourseParams
func (_e *MockQuerier_Expecter) UpdateCourse(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateCourse_Call {
	return &MockQuerier_UpdateCourse_Call{Call: _e.mock.On("UpdateCourse", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateCourse_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateCourseParams)) *MockQuerier_UpdateCourse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateCourseParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateCourse_Call) Return(_a0 Course, _a1 error) *MockQuerier_UpdateCourse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateCourse_Call) RunAndReturn(run func(context.Context, DBTX, UpdateCourseParams) (Course, error)) *MockQuerier_UpdateCourse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStudent provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateStudent(ctx context.Context, db DBTX, arg UpdateStudentParams) (Student, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStudent")
	}

	var r0 Student
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateStudentParams) (Student, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateStudentParams) Student); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(Student)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateStudentParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateStudent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStudent'
type MockQuerier_UpdateStudent_Call struct {
	*mock.Call
}

// UpdateStudent is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateStudentParams
func (_e *MockQuerier_Expecter) UpdateStudent(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateStudent_Call {
	return &MockQuerier_UpdateStudent_Call{Call: _e.mock.On("UpdateStudent", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateStudent_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateStudentParams)) *MockQuerier_UpdateStudent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateStudentParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateStudent_Call) Return(_a0 Student, _a1 error) *MockQuerier_UpdateStudent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateStudent_Call) RunAndReturn(run func(context.Context, DBTX, UpdateStudentParams) (Student, error)) *MockQuerier_UpdateStudent_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTemplate provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateTemplate(ctx context.Context, db DBTX, arg UpdateTemplateParams) (Template, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTemplate")
	}

	var r0 Template
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateTemplateParams) (Template, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateTemplateParams) Template); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(Template)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateTemplateParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTemplate'
type MockQuerier_UpdateTemplate_Call struct {
	*mock.Call
}

// UpdateTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateTemplateParams
func (_e *MockQuerier_Expecter) UpdateTemplate(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateTemplate_Call {
	return &MockQuerier_UpdateTemplate_Call{Call: _e.mock.On("UpdateTemplate", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateTemplate_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateTemplateParams)) *MockQuerier_UpdateTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateTemplateParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateTemplate_Call) Return(_a0 Template, _a1 error) *MockQuerier_UpdateTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateTemplate_Call) RunAndReturn(run func(context.Context, DBTX, UpdateTemplateParams) (Template, error)) *MockQuerier_UpdateTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockQuerier creates a new instance of MockQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockQuerier {
	mock := &MockQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
